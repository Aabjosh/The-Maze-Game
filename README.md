# The-Maze-Game
This is a custom maze generation and solving game, which employs the use of a prim maze generation algorithm, as well as a modified a-star search autosolving algorithm. A variety of features are included, such as a custom mode, UI themes (2), percentage accuracy and score ranking...

## The Behind-The-Scenes
The Maze Game is programmed 100% in Python, and comprised of three main files. These are the "main.py" file, the "maze_solver.py" file, and the "prim_maze_generation.py" file. The two latter files are called upon by the "main.py" file to run embedded functions, which are coupled to the custom PyGame UI I created. 

### main.py
This file is very straight forward in that it is the backbone of the game. Here, all the assets including icons, fonts, backgrounds, colours, the PyGame library, and the two other files, are all imported and implemented. This file uses the PyGame library to take human input to decide between four game modes.
- Easy:

  A 30x30 maze, randomely generated by the "prim_maze_generation.py" file
- Medium:

  A 45x45 maze, randomely generated by the "prim_maze_generation.py" file
- Hard:

  A 70x70 maze, randomely generated by the "prim_maze_generation.py" file
- Custom:

  A custom and random maze generated between widths and lengths of 5u -> 300u
The game keeps track of every completed maze of each category, and sorts the completions by percentage score, calculated as the total number of correct positions divided by the number of moves taken. Upon completion of a maze, the score is displayed in green, yellow, or red, corresponding to the magnitude of accuracy (descending respectively). Scores are not saved in a .json or .txt after termination - no information is saved.

Controls and functionality are outlined in the game...

### maze_solver.py
Refer to "Maze_Solver_Explanation.webm" in the "Videos" folder for information. 
Essentially, this file uses a modified a-star algorithm to determine a manhattan distance (cost) to solve the maze, moves from the starting point biased towards the opposing corner, and remembers current paths and intersections. Upon running into a "dead end" of three walls, it returns to its most recent intersection and deletes the most recent path, upon where that path that lead to dead ends is deleted. If none of the intersection's directions lead to an open path, the most recent intersection and paths are deleted, and the runner-up intersection is re-examined for a different direction. This is done until the maze is fully solved, yielding an array of the least amount of positions required to escape the maze. This is fed to the "Autosolver" method. 

### prim_maze_generation.py
To be written...

###Functionality Notes:
To be written...
